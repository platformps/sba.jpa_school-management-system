package com.github.perscholas.service;

import com.github.perscholas.DatabaseConnection;
import com.github.perscholas.dao.StudentDao;
import com.github.perscholas.model.CourseInterface;
import com.github.perscholas.model.Student;
import com.github.perscholas.model.StudentInterface;


import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

// Implement StudentDAO interface

public class StudentService implements StudentDao {
    private final DatabaseConnection dbc;

    // constructor takes dbc
    public StudentService(DatabaseConnection dbc) {

        this.dbc = dbc;
    }

    public StudentService() {

        this(DatabaseConnection.UAT);
    }
    /**
     * reads the student table in database
     * @return database data as a List<Student>
     */
    @Override
    public List<StudentInterface> getAllStudents() {
        ResultSet rs = dbc.executeQuery("SELECT * FROM student");
        try {
            //Parse `List<StudentInterface>` from `resultSet`
            List<StudentInterface> students = new ArrayList<>();
            while (rs.next()) {
                students.add(new Student(
                        rs.getString("email"),
                        rs.getString("name"),
                        rs.getString("password")));
            }
            return students; // returns list
        } catch (Exception e) {
            throw new Error(e);
        }
    }

    /**
     * takes a Student’s email as a String and parses the student list
     * for a Student with that email and returns a Student Object.
     * @param studentEmail - student's email to be parsed
     * @return the student list of a Student with respective `studentEmail`
     */
    @Override
    public StudentInterface getStudentByEmail(String studentEmail) {
        try {
            return getAllStudents()
                    .stream()
                    .filter(student -> student.getEmail().equals(studentEmail))//process element
                    .findFirst()//terminal operation
                    .get(); //retrieve Student by email
        } catch (NullPointerException e) {
            System.out.println("Invalid entry");
            throw new RuntimeException (e);
        }
    }

    /**
     * This method takes two parameters: the first one is the user email and the second one is the password from the user input.
     * @param studentEmail - email student uses to log in
     * @param password - password student uses to log in
     * @return `true` if a student was found; else `false`
     */
    @Override
    public Boolean validateStudent(String studentEmail, String password) {
        boolean isValidStudent = getAllStudents()
                .stream()
                .anyMatch(student -> student.getEmail().equals(studentEmail) &&
                        student.getPassword().equals(password)); // anyMatch returns true as predicate applied to input element
        if (isValidStudent) {
            return true;
        } else {
            System.out.println("Wrong Credentials. Please enter valid email and password:");
        }
        return null;
    }

    /**
     * After a successful student validation, this method takes a Student’s email and a Course ID.
     * It checks in the join table (i.e. Student_Course) generated by JPA to find if a Student with that Email is currently attending a Course with that ID.
     * If the Student is not attending that Course, register the student to that course; otherwise not
     * @param studentEmail - email student uses to log in
     * @param courseId - id of course student wishes to register to
     */
    @Override
    public void registerStudentToCourse(String studentEmail, int courseId) {
        List<CourseInterface> studentCourses = getStudentCourses(studentEmail);
        Optional<CourseInterface> course = studentCourses
                .stream()
                .filter(crs -> crs.getId() == courseId)
                .findFirst();
        if (course.isPresent()) {
            course.ifPresent(crs -> System.out.println("Registered user"));
        }

        String query = "INSERT INTO student_course values (?, ?)";
        try {
            PreparedStatement preparedStatement = dbc.getDatabaseConnection().prepareStatement(query);
            preparedStatement.setString(1, studentEmail);
            preparedStatement.setInt(2, courseId);
            preparedStatement.execute();

        } catch (SQLException e) {
            System.out.println(e);
        }
    }
    /**
     * This method takes a Student’s Email as a parameter and would find all the courses a student is registered.
     * @param studentEmail - student's email to be parsed
     * @return list of courses student has registered to
     */
    @Override
    public List<CourseInterface> getStudentCourses(String studentEmail) {
        List<CourseInterface> studentCourses = getStudentCourses(studentEmail);
        String query = "SELECT * FROM student_course WHERE student_email=?";
        try {
            PreparedStatement preparedStatement = dbc.getDatabaseConnection().prepareStatement(query);
            preparedStatement.setString(1, studentEmail);
            ResultSet resultSet = preparedStatement.executeQuery();

            while(resultSet.next()) {
                int courseId = resultSet.getInt("Course_id");
                studentCourses.add(new CourseService().getAllCourses()
                        .stream()
                        .filter(crs -> crs.getId() == courseId)
                        .findFirst()
                        .get());
            }
        } catch(Exception e) {
        e.printStackTrace();
        throw new RuntimeException();
        }
        return studentCourses;
    }
}
