package com.github.perscholas.service;

import com.github.perscholas.DatabaseConnection;
import com.github.perscholas.dao.StudentDao;
import com.github.perscholas.model.Course;
import com.github.perscholas.model.CourseInterface;
import com.github.perscholas.model.Student;
import com.github.perscholas.model.StudentInterface;
import com.github.perscholas.utils.IOConsole;

import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;


// TODO - Implement respective DAO interface
public class StudentService implements StudentDao {
    private final DatabaseConnection dbc;
    private final IOConsole console = new IOConsole();

    public StudentService(DatabaseConnection dbc) {

        this.dbc = dbc;
    }

    public StudentService() {
        this(DatabaseConnection.MANAGEMENT_SYSTEM);  //UAT);
    }

    /**
     * reads the student table in database
     * @return database data as a List<Student>
     */
    @Override
    public List<StudentInterface> getAllStudents() {
        ResultSet resultSet = dbc.executeQuery("SELECT * FROM students");
        try {

            List<StudentInterface> studentInterfaceList = new ArrayList<>();
            while(resultSet.next()) {
                Student student = new Student();
                student.setEmail(resultSet.getString("email"));
                student.setName(resultSet.getString("name"));
                student.setPassword(resultSet.getString("password"));
                studentInterfaceList.add(student);
            }
            return studentInterfaceList;
        } catch(Exception e) {
            throw new Error(e);
        }
    }

    /**
     * takes a Student’s email as a String and parses the student list for a Student with that email and returns a Student Object.
     * @param studentEmail - student's email to be parsed
     * @return the student list of a Student with respective `studentEmail`
     */
    @Override
    public StudentInterface getStudentByEmail(String studentEmail) {

        return getAllStudents()
                .stream()
                .filter(student -> student.getEmail().equals(studentEmail))
                .findFirst()
                .get();
    }

    /**
     * This method takes two parameters: the first one is the user email and the second one is the password from the user input.
     * @param studentEmail - email student uses to log in
     * @param password - password student uses to log in
     * @return `true` if a student was found; else `false`
     */
    @Override
    public Boolean validateStudent(String studentEmail, String password) {

        try {
  //          if(getStudentByEmail(studentEmail) != null && getStudentByEmail(studentEmail).getPassword().equals(password)) {
            if(password.equals(Objects.requireNonNull(getStudentByEmail(studentEmail)).getPassword())) {
                return true;
            } else {
                return false;
            }
        }catch(Exception e){
            return false;
        }
    }

    /**
     * After a successful student validation, this method takes a Student’s email and a Course ID.
     * It checks in the join table (i.e. Student_Course) generated by JPA to find if a Student with that Email is currently attending a Course with that ID.
     * If the Student is not attending that Course, register the student to that course; otherwise not
     * @param studentEmail - email student uses to log in
     * @param courseId - id of course student wishes to register to
     */
    @Override///////-------------------
    public void registerStudentToCourse(String studentEmail, int courseId) {

        Optional<CourseInterface> courseTest = getStudentCourses(studentEmail)
                      .stream()
                       .filter(course -> (course.getId() == courseId))
                       .findFirst();

        if(courseTest.isPresent()){
            console.println("\n" + studentEmail + " is already registered for " + courseId + "\n");
                  return;
        }

           try {
               dbc.executeStatement("INSERT INTO management_system.Student_Course (student_email, course_id)" +
                       "VALUES ('" + studentEmail + "','" + courseId + "')");

           } catch (Exception e) {  ////
               console.println("INSERTING INTO THE TABLE DID NOT WORK");
           }

        List<CourseInterface> courses = new StudentService().getStudentCourses(studentEmail);
        console.println(new StringBuilder()
                .append("[ %s ] is registered to the following courses:")
                .append("\n\t" + courses)
                .toString(), studentEmail);
       }



    /**
     * This method takes a Student’s Email as a parameter and would find all the courses a student is registered.
     * @param studentEmail - student's email to be parsed
     * @return list of courses student has registered to
     */
    @Override
    public List<CourseInterface> getStudentCourses(String studentEmail) {

        List<CourseInterface> courseInterfaceList = new ArrayList<>();
                ResultSet resultSet = dbc.executeQuery("SELECT * FROM Student_Course WHERE student_email = '" + studentEmail + "'");
                try {

                    while(resultSet.next()) {
                        int courseId = resultSet.getInt("course_id");
                        courseInterfaceList.add(new CourseService().getAllCourses()
                        .stream()
                        .filter(course ->course.getId() == courseId)
                        .findFirst()
                        .get())
                        ;

                    }

                } catch(Exception e) {
                    throw new Error(e);
                }
        return courseInterfaceList;
            }
}